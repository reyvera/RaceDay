[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar meteorInstall = Package['modules-runtime'].meteorInstall;\n\n/* Package-scope variables */\nvar Buffer, process;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"modules\":{\"server.js\":[\"./install-packages.js\",\"./buffer.js\",\"./process.js\",\"reify/lib/runtime\",function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////\n//                                                                              //\n// packages/modules/server.js                                                   //\n//                                                                              //\n//////////////////////////////////////////////////////////////////////////////////\n                                                                                //\nrequire(\"./install-packages.js\");\nrequire(\"./buffer.js\");\nrequire(\"./process.js\");\nrequire(\"reify/lib/runtime\").enable(module.constructor);\n\n//////////////////////////////////////////////////////////////////////////////////\n\n}],\"buffer.js\":[\"buffer\",function(require){\n\n//////////////////////////////////////////////////////////////////////////////////\n//                                                                              //\n// packages/modules/buffer.js                                                   //\n//                                                                              //\n//////////////////////////////////////////////////////////////////////////////////\n                                                                                //\ntry {\n  Buffer = global.Buffer || require(\"buffer\").Buffer;\n} catch (noBuffer) {}\n\n//////////////////////////////////////////////////////////////////////////////////\n\n}],\"install-packages.js\":function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////\n//                                                                              //\n// packages/modules/install-packages.js                                         //\n//                                                                              //\n//////////////////////////////////////////////////////////////////////////////////\n                                                                                //\nfunction install(name, mainModule) {\n  var meteorDir = {};\n\n  // Given a package name <name>, install a stub module in the\n  // /node_modules/meteor directory called <name>.js, so that\n  // require.resolve(\"meteor/<name>\") will always return\n  // /node_modules/meteor/<name>.js instead of something like\n  // /node_modules/meteor/<name>/index.js, in the rare but possible event\n  // that the package contains a file called index.js (#6590).\n\n  if (mainModule) {\n    meteorDir[name + \".js\"] = [mainModule, function (require, e, module) {\n      module.exports = require(mainModule);\n    }];\n  } else {\n    // back compat with old Meteor packages\n    meteorDir[name + \".js\"] = function (r, e, module) {\n      module.exports = Package[name];\n    };\n  }\n\n  meteorInstall({\n    node_modules: {\n      meteor: meteorDir\n    }\n  });\n}\n\n// This file will be modified during computeJsOutputFilesMap to include\n// install(<name>) calls for every Meteor package.\n\ninstall(\"underscore\");\ninstall(\"meteor\");\ninstall(\"meteor-base\");\ninstall(\"mobile-experience\");\ninstall(\"npm-mongo\");\ninstall(\"babel-compiler\");\ninstall(\"ecmascript\");\ninstall(\"base64\");\ninstall(\"ejson\");\ninstall(\"id-map\");\ninstall(\"ordered-dict\");\ninstall(\"tracker\");\ninstall(\"modules-runtime\");\ninstall(\"modules\", \"meteor/modules/server.js\");\ninstall(\"es5-shim\", \"meteor/es5-shim/server.js\");\ninstall(\"promise\", \"meteor/promise/server.js\");\ninstall(\"ecmascript-runtime\", \"meteor/ecmascript-runtime/runtime.js\");\ninstall(\"babel-runtime\");\ninstall(\"random\");\ninstall(\"mongo-id\");\ninstall(\"diff-sequence\");\ninstall(\"geojson-utils\", \"meteor/geojson-utils/main.js\");\ninstall(\"minimongo\");\ninstall(\"check\", \"meteor/check/match.js\");\ninstall(\"retry\");\ninstall(\"ddp-common\");\ninstall(\"ddp-client\");\ninstall(\"logging\");\ninstall(\"routepolicy\");\ninstall(\"deps\");\ninstall(\"htmljs\");\ninstall(\"html-tools\");\ninstall(\"blaze-tools\");\ninstall(\"spacebars-compiler\");\ninstall(\"jquery\");\ninstall(\"observe-sequence\");\ninstall(\"reactive-var\");\ninstall(\"blaze\");\ninstall(\"spacebars\");\ninstall(\"ui\");\ninstall(\"boilerplate-generator\");\ninstall(\"webapp-hashing\");\ninstall(\"webapp\");\ninstall(\"callback-hook\");\ninstall(\"ddp-server\");\ninstall(\"ddp\");\ninstall(\"allow-deny\");\ninstall(\"binary-heap\");\ninstall(\"insecure\");\ninstall(\"mongo\");\ninstall(\"blaze-html-templates\");\ninstall(\"standard-minifier-css\");\ninstall(\"standard-minifier-js\");\ninstall(\"reactive-dict\");\ninstall(\"kadira:flow-router\");\ninstall(\"meteortoys:toykit\");\ninstall(\"msavin:mongol\");\ninstall(\"msavin:jetsetter\");\ninstall(\"meteortoys:blueprint\");\ninstall(\"meteortoys:authenticate\");\ninstall(\"meteortoys:shell\");\ninstall(\"meteortoys:method\");\ninstall(\"meteortoys:result\");\ninstall(\"meteortoys:autopub\");\ninstall(\"meteortoys:pub\");\ninstall(\"meteortoys:sub\");\ninstall(\"email\");\ninstall(\"meteortoys:email\");\ninstall(\"meteortoys:listen\");\ninstall(\"meteortoys:throttle\");\ninstall(\"meteortoys:status\");\ninstall(\"meteortoys:hotreload\");\ninstall(\"meteortoys:allthings\");\ninstall(\"ultimatejs:tracker-react\", \"meteor/ultimatejs:tracker-react/main.js\");\ninstall(\"stolinski:stylus-multi\");\ninstall(\"livedata\");\ninstall(\"hot-code-push\");\ninstall(\"launch-screen\");\ninstall(\"templating\");\ninstall(\"autoupdate\");\ninstall(\"reload\");\n\n//////////////////////////////////////////////////////////////////////////////////\n\n},\"process.js\":[\"process\",function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////\n//                                                                              //\n// packages/modules/process.js                                                  //\n//                                                                              //\n//////////////////////////////////////////////////////////////////////////////////\n                                                                                //\ntry {\n  // The application can run `npm install process` to provide its own\n  // process stub; otherwise this module will provide a partial stub.\n  process = global.process || require(\"process\");\n} catch (noProcess) {\n  process = {};\n}\n\nif (Meteor.isServer) {\n  // Make require(\"process\") work on the server in all versions of Node.\n  meteorInstall({\n    node_modules: {\n      \"process.js\": function (r, e, module) {\n        module.exports = process;\n      }\n    }\n  });\n} else {\n  process.platform = \"browser\";\n  process.nextTick = process.nextTick || Meteor._setImmediate;\n}\n\nif (typeof process.env !== \"object\") {\n  process.env = {};\n}\n\n_.extend(process.env, meteorEnv);\n\n//////////////////////////////////////////////////////////////////////////////////\n\n}],\"node_modules\":{\"reify\":{\"lib\":{\"runtime.js\":[\"./entry.js\",function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////\n//                                                                              //\n// node_modules/meteor/modules/node_modules/reify/lib/runtime.js                //\n//                                                                              //\n//////////////////////////////////////////////////////////////////////////////////\n                                                                                //\nvar Entry = require(\"./entry.js\").Entry;\n\nexports.enable = function (Module) {\n  var Mp = Module.prototype;\n\n  if (typeof Mp.import === \"function\" &&\n      typeof Mp.export === \"function\") {\n    // If the Mp.{import,export} methods have already been\n    // defined, abandon reification immediately.\n    return Module;\n  }\n\n  // Platform-specific code should implement this method however\n  // appropriate. Module.prototype.resolve(id) should return an absolute\n  // version of the given module identifier, like require.resolve.\n  Mp.resolve = Mp.resolve || function resolve(id) {\n    throw new Error(\"Module.prototype.resolve not implemented\");\n  };\n\n  // Platform-specific code should find a way to call this method whenever\n  // the module system is about to return module.exports from require. This\n  // might happen more than once per module, in case of dependency cycles,\n  // so we want Module.prototype.runModuleSetters to run each time.\n  Mp.runModuleSetters = function runModuleSetters() {\n    var entry = Entry.get(this.id);\n    if (entry) {\n      entry.runModuleSetters(this);\n    }\n  };\n\n  function setESModule(module) {\n    var exports = module.exports;\n    if (exports && typeof exports === \"object\") {\n      exports.__esModule = true;\n    }\n  }\n\n  Mp.import = function (id, setters) {\n    var module = this;\n    setESModule(module);\n\n    var absoluteId = module.resolve(id);\n\n    if (setters && typeof setters === \"object\") {\n      var entry = Entry.getOrCreate(absoluteId);\n      entry.addSetters(setters);\n      entry.addParent(module);\n    }\n\n    var countBefore = entry && entry.runCount;\n    var exports = typeof module.require === \"function\"\n      ? module.require(absoluteId)\n      : require(absoluteId);\n\n    if (entry && entry.runCount === countBefore) {\n      // If require(absoluteId) didn't run any setters for this entry,\n      // perhaps because it's not the first time this module has been\n      // required, run the setters now using an object that passes as the\n      // real module object.\n      entry.runModuleSetters({\n        id: absoluteId,\n        exports: exports,\n        getExportByName: Mp.getExportByName\n      });\n    }\n  };\n\n  // Register a getter function for a local variable in the scope of an\n  // export statement.\n  Mp.export = function (id, getter) {\n    var module = this;\n    setESModule(module);\n\n    var entry = Entry.getOrCreate(module.id);\n\n    if (typeof id === \"string\") {\n      entry.addGetter(id, getter);\n    } else if (typeof id === \"object\") {\n      entry.addGetters(id);\n    }\n\n    if (module.loaded) {\n      // If the module has already been evaluated, then we need to trigger\n      // another round of entry.runModuleSetters calls, which begins by\n      // calling entry.runModuleGetters(module).\n      entry.runModuleSetters(module);\n    } else {\n      // If the module has not yet finished evaluating, then we only want\n      // to call entry.runModuleGetters(module) to update module.exports.\n      entry.runModuleGetters(module);\n    }\n  };\n\n  // This method can be overridden by client code to implement custom export\n  // naming logic. The current implementation works well with Babel's\n  // __esModule convention.\n  Mp.getExportByName = function (name) {\n    var exports = this.exports;\n\n    if (name === \"*\") {\n      return exports;\n    }\n\n    if (name === \"default\" &&\n        ! (exports &&\n           typeof exports === \"object\" &&\n           exports.__esModule &&\n           \"default\" in exports)) {\n      return exports;\n    }\n\n    return exports && exports[name];\n  };\n\n  return Module;\n};\n\n//////////////////////////////////////////////////////////////////////////////////\n\n}],\"entry.js\":function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////\n//                                                                              //\n// node_modules/meteor/modules/node_modules/reify/lib/entry.js                  //\n//                                                                              //\n//////////////////////////////////////////////////////////////////////////////////\n                                                                                //\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar entryMap = Object.create(null);\n\nfunction Entry(id) {\n  // Same as module.id for this module.\n  this.id = id;\n  // The number of times this.runModuleSetters has been called.\n  this.runCount = 0;\n  // Map from parent module identifiers to parent module objects.\n  this.parents = Object.create(null);\n  // Setters for assigning to local variables in parent modules.\n  this.setters = Object.create(null);\n  // Getters for local variables exported from this module.\n  this.getters = Object.create(null);\n}\n\nvar Ep = Entry.prototype;\n\nEntry.get = function (id) {\n  return entryMap[id] || null;\n};\n\nEntry.getOrCreate = function (id) {\n  return entryMap[id] = entryMap[id] || new Entry(id);\n};\n\nEp.addParent = function (module) {\n  this.parents[module.id] = module;\n};\n\nEp.addSetters = function (setters) {\n  Object.keys(setters).forEach(function (name) {\n    this.addSetter(name, setters[name]);\n  }, this);\n};\n\nEp.addSetter = function (name, setter) {\n  if (typeof name === \"string\" &&\n      typeof setter === \"function\" &&\n      // Ignore any requests for the exports.__esModule property.\"\n      name !== \"__esModule\") {\n    (this.setters[name] =\n     this.setters[name] || []\n    ).push(setter);\n  }\n};\n\nEp.addGetters = function (getters) {\n  Object.keys(getters).forEach(function (name) {\n    this.addGetter(name, getters[name]);\n  }, this);\n};\n\nEp.addGetter = function (name, getter) {\n  if (typeof name === \"string\" &&\n      typeof getter === \"function\" &&\n      // Ignore any requests for the exports.__esModule property.\"\n      name !== \"__esModule\") {\n    // Should this throw if hasOwn.call(this.getters, name)?\n    this.getters[name] = getter;\n  }\n};\n\nfunction runModuleSetters(module) {\n  var entry = entryMap[module.id];\n  if (entry) {\n    entry.runModuleSetters(module);\n  }\n}\n\nEp.runModuleGetters = function (module) {\n  var entry = this;\n  Object.keys(entry.getters).forEach(function (name) {\n    // Make sure we update module.exports[name] with the current value so\n    // that CommonJS require calls remain consistent with module.import.\n    module.exports[name] = entry.getters[name].call(module);\n  });\n};\n\nEp.runModuleSetters = function (module) {\n  var entry = this;\n  var shouldRunParentSetters = false;\n\n  this.runModuleGetters(module);\n\n  Object.keys(entry.setters).forEach(function (name) {\n    var value = module.getExportByName(name);\n\n    entry.setters[name].forEach(function (setter) {\n      if (name === \"*\") {\n        Object.keys(value).forEach(function (name) {\n          if (name !== \"__esModule\" &&\n              callSetter(module, setter, name, value[name]) === true) {\n            shouldRunParentSetters = true;\n          }\n        });\n      } else if (callSetter(module, setter, name, value) === true) {\n        shouldRunParentSetters = true;\n      }\n    });\n  });\n\n  ++entry.runCount;\n\n  if (shouldRunParentSetters) {\n    entry.runParentSetters();\n  }\n};\n\nfunction callSetter(module, setter, name, value) {\n  setter.last = setter.last || Object.create(null);\n  if (! hasOwn.call(setter.last, name) ||\n      value !== setter.last[name]) {\n    return setter.call(\n      module,\n      setter.last[name] = value,\n      name\n    );\n  }\n}\n\nEp.runParentSetters = function () {\n  var parents = this.parents;\n  Object.keys(parents).forEach(function (id) {\n    runModuleSetters(parents[id]);\n  });\n};\n\nexports.Entry = Entry;\n\n//////////////////////////////////////////////////////////////////////////////////\n\n}}}}}}}},{\"extensions\":[\".js\",\".json\"]});\nvar exports = require(\"./node_modules/meteor/modules/server.js\");\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package.modules = exports, {\n  meteorInstall: meteorInstall,\n  Buffer: Buffer,\n  process: process\n});\n\n})();\n","servePath":"/packages/modules.js","sourceMap":{"version":3,"sources":["/packages/modules/server.js","/packages/modules/buffer.js","/packages/modules/install-packages.js","/packages/modules/process.js","node_modules/meteor/modules/node_modules/reify/lib/runtime.js","node_modules/meteor/modules/node_modules/reify/lib/entry.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;;;;;;;;;;;ACHA;AACA;AACA;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/packages/modules.js","sourcesContent":["require(\"./install-packages.js\");\nrequire(\"./buffer.js\");\nrequire(\"./process.js\");\nrequire(\"reify/lib/runtime\").enable(module.constructor);\n","try {\n  Buffer = global.Buffer || require(\"buffer\").Buffer;\n} catch (noBuffer) {}\n","function install(name, mainModule) {\n  var meteorDir = {};\n\n  // Given a package name <name>, install a stub module in the\n  // /node_modules/meteor directory called <name>.js, so that\n  // require.resolve(\"meteor/<name>\") will always return\n  // /node_modules/meteor/<name>.js instead of something like\n  // /node_modules/meteor/<name>/index.js, in the rare but possible event\n  // that the package contains a file called index.js (#6590).\n\n  if (mainModule) {\n    meteorDir[name + \".js\"] = [mainModule, function (require, e, module) {\n      module.exports = require(mainModule);\n    }];\n  } else {\n    // back compat with old Meteor packages\n    meteorDir[name + \".js\"] = function (r, e, module) {\n      module.exports = Package[name];\n    };\n  }\n\n  meteorInstall({\n    node_modules: {\n      meteor: meteorDir\n    }\n  });\n}\n\n// This file will be modified during computeJsOutputFilesMap to include\n// install(<name>) calls for every Meteor package.\n\ninstall(\"underscore\");\ninstall(\"meteor\");\ninstall(\"meteor-base\");\ninstall(\"mobile-experience\");\ninstall(\"npm-mongo\");\ninstall(\"babel-compiler\");\ninstall(\"ecmascript\");\ninstall(\"base64\");\ninstall(\"ejson\");\ninstall(\"id-map\");\ninstall(\"ordered-dict\");\ninstall(\"tracker\");\ninstall(\"modules-runtime\");\ninstall(\"modules\", \"meteor/modules/server.js\");\ninstall(\"es5-shim\", \"meteor/es5-shim/server.js\");\ninstall(\"promise\", \"meteor/promise/server.js\");\ninstall(\"ecmascript-runtime\", \"meteor/ecmascript-runtime/runtime.js\");\ninstall(\"babel-runtime\");\ninstall(\"random\");\ninstall(\"mongo-id\");\ninstall(\"diff-sequence\");\ninstall(\"geojson-utils\", \"meteor/geojson-utils/main.js\");\ninstall(\"minimongo\");\ninstall(\"check\", \"meteor/check/match.js\");\ninstall(\"retry\");\ninstall(\"ddp-common\");\ninstall(\"ddp-client\");\ninstall(\"logging\");\ninstall(\"routepolicy\");\ninstall(\"deps\");\ninstall(\"htmljs\");\ninstall(\"html-tools\");\ninstall(\"blaze-tools\");\ninstall(\"spacebars-compiler\");\ninstall(\"jquery\");\ninstall(\"observe-sequence\");\ninstall(\"reactive-var\");\ninstall(\"blaze\");\ninstall(\"spacebars\");\ninstall(\"ui\");\ninstall(\"boilerplate-generator\");\ninstall(\"webapp-hashing\");\ninstall(\"webapp\");\ninstall(\"callback-hook\");\ninstall(\"ddp-server\");\ninstall(\"ddp\");\ninstall(\"allow-deny\");\ninstall(\"binary-heap\");\ninstall(\"insecure\");\ninstall(\"mongo\");\ninstall(\"blaze-html-templates\");\ninstall(\"standard-minifier-css\");\ninstall(\"standard-minifier-js\");\ninstall(\"reactive-dict\");\ninstall(\"kadira:flow-router\");\ninstall(\"meteortoys:toykit\");\ninstall(\"msavin:mongol\");\ninstall(\"msavin:jetsetter\");\ninstall(\"meteortoys:blueprint\");\ninstall(\"meteortoys:authenticate\");\ninstall(\"meteortoys:shell\");\ninstall(\"meteortoys:method\");\ninstall(\"meteortoys:result\");\ninstall(\"meteortoys:autopub\");\ninstall(\"meteortoys:pub\");\ninstall(\"meteortoys:sub\");\ninstall(\"email\");\ninstall(\"meteortoys:email\");\ninstall(\"meteortoys:listen\");\ninstall(\"meteortoys:throttle\");\ninstall(\"meteortoys:status\");\ninstall(\"meteortoys:hotreload\");\ninstall(\"meteortoys:allthings\");\ninstall(\"ultimatejs:tracker-react\", \"meteor/ultimatejs:tracker-react/main.js\");\ninstall(\"stolinski:stylus-multi\");\ninstall(\"livedata\");\ninstall(\"hot-code-push\");\ninstall(\"launch-screen\");\ninstall(\"templating\");\ninstall(\"autoupdate\");\ninstall(\"reload\");\n","try {\n  // The application can run `npm install process` to provide its own\n  // process stub; otherwise this module will provide a partial stub.\n  process = global.process || require(\"process\");\n} catch (noProcess) {\n  process = {};\n}\n\nif (Meteor.isServer) {\n  // Make require(\"process\") work on the server in all versions of Node.\n  meteorInstall({\n    node_modules: {\n      \"process.js\": function (r, e, module) {\n        module.exports = process;\n      }\n    }\n  });\n} else {\n  process.platform = \"browser\";\n  process.nextTick = process.nextTick || Meteor._setImmediate;\n}\n\nif (typeof process.env !== \"object\") {\n  process.env = {};\n}\n\n_.extend(process.env, meteorEnv);\n","var Entry = require(\"./entry.js\").Entry;\n\nexports.enable = function (Module) {\n  var Mp = Module.prototype;\n\n  if (typeof Mp.import === \"function\" &&\n      typeof Mp.export === \"function\") {\n    // If the Mp.{import,export} methods have already been\n    // defined, abandon reification immediately.\n    return Module;\n  }\n\n  // Platform-specific code should implement this method however\n  // appropriate. Module.prototype.resolve(id) should return an absolute\n  // version of the given module identifier, like require.resolve.\n  Mp.resolve = Mp.resolve || function resolve(id) {\n    throw new Error(\"Module.prototype.resolve not implemented\");\n  };\n\n  // Platform-specific code should find a way to call this method whenever\n  // the module system is about to return module.exports from require. This\n  // might happen more than once per module, in case of dependency cycles,\n  // so we want Module.prototype.runModuleSetters to run each time.\n  Mp.runModuleSetters = function runModuleSetters() {\n    var entry = Entry.get(this.id);\n    if (entry) {\n      entry.runModuleSetters(this);\n    }\n  };\n\n  function setESModule(module) {\n    var exports = module.exports;\n    if (exports && typeof exports === \"object\") {\n      exports.__esModule = true;\n    }\n  }\n\n  Mp.import = function (id, setters) {\n    var module = this;\n    setESModule(module);\n\n    var absoluteId = module.resolve(id);\n\n    if (setters && typeof setters === \"object\") {\n      var entry = Entry.getOrCreate(absoluteId);\n      entry.addSetters(setters);\n      entry.addParent(module);\n    }\n\n    var countBefore = entry && entry.runCount;\n    var exports = typeof module.require === \"function\"\n      ? module.require(absoluteId)\n      : require(absoluteId);\n\n    if (entry && entry.runCount === countBefore) {\n      // If require(absoluteId) didn't run any setters for this entry,\n      // perhaps because it's not the first time this module has been\n      // required, run the setters now using an object that passes as the\n      // real module object.\n      entry.runModuleSetters({\n        id: absoluteId,\n        exports: exports,\n        getExportByName: Mp.getExportByName\n      });\n    }\n  };\n\n  // Register a getter function for a local variable in the scope of an\n  // export statement.\n  Mp.export = function (id, getter) {\n    var module = this;\n    setESModule(module);\n\n    var entry = Entry.getOrCreate(module.id);\n\n    if (typeof id === \"string\") {\n      entry.addGetter(id, getter);\n    } else if (typeof id === \"object\") {\n      entry.addGetters(id);\n    }\n\n    if (module.loaded) {\n      // If the module has already been evaluated, then we need to trigger\n      // another round of entry.runModuleSetters calls, which begins by\n      // calling entry.runModuleGetters(module).\n      entry.runModuleSetters(module);\n    } else {\n      // If the module has not yet finished evaluating, then we only want\n      // to call entry.runModuleGetters(module) to update module.exports.\n      entry.runModuleGetters(module);\n    }\n  };\n\n  // This method can be overridden by client code to implement custom export\n  // naming logic. The current implementation works well with Babel's\n  // __esModule convention.\n  Mp.getExportByName = function (name) {\n    var exports = this.exports;\n\n    if (name === \"*\") {\n      return exports;\n    }\n\n    if (name === \"default\" &&\n        ! (exports &&\n           typeof exports === \"object\" &&\n           exports.__esModule &&\n           \"default\" in exports)) {\n      return exports;\n    }\n\n    return exports && exports[name];\n  };\n\n  return Module;\n};\n","var hasOwn = Object.prototype.hasOwnProperty;\nvar entryMap = Object.create(null);\n\nfunction Entry(id) {\n  // Same as module.id for this module.\n  this.id = id;\n  // The number of times this.runModuleSetters has been called.\n  this.runCount = 0;\n  // Map from parent module identifiers to parent module objects.\n  this.parents = Object.create(null);\n  // Setters for assigning to local variables in parent modules.\n  this.setters = Object.create(null);\n  // Getters for local variables exported from this module.\n  this.getters = Object.create(null);\n}\n\nvar Ep = Entry.prototype;\n\nEntry.get = function (id) {\n  return entryMap[id] || null;\n};\n\nEntry.getOrCreate = function (id) {\n  return entryMap[id] = entryMap[id] || new Entry(id);\n};\n\nEp.addParent = function (module) {\n  this.parents[module.id] = module;\n};\n\nEp.addSetters = function (setters) {\n  Object.keys(setters).forEach(function (name) {\n    this.addSetter(name, setters[name]);\n  }, this);\n};\n\nEp.addSetter = function (name, setter) {\n  if (typeof name === \"string\" &&\n      typeof setter === \"function\" &&\n      // Ignore any requests for the exports.__esModule property.\"\n      name !== \"__esModule\") {\n    (this.setters[name] =\n     this.setters[name] || []\n    ).push(setter);\n  }\n};\n\nEp.addGetters = function (getters) {\n  Object.keys(getters).forEach(function (name) {\n    this.addGetter(name, getters[name]);\n  }, this);\n};\n\nEp.addGetter = function (name, getter) {\n  if (typeof name === \"string\" &&\n      typeof getter === \"function\" &&\n      // Ignore any requests for the exports.__esModule property.\"\n      name !== \"__esModule\") {\n    // Should this throw if hasOwn.call(this.getters, name)?\n    this.getters[name] = getter;\n  }\n};\n\nfunction runModuleSetters(module) {\n  var entry = entryMap[module.id];\n  if (entry) {\n    entry.runModuleSetters(module);\n  }\n}\n\nEp.runModuleGetters = function (module) {\n  var entry = this;\n  Object.keys(entry.getters).forEach(function (name) {\n    // Make sure we update module.exports[name] with the current value so\n    // that CommonJS require calls remain consistent with module.import.\n    module.exports[name] = entry.getters[name].call(module);\n  });\n};\n\nEp.runModuleSetters = function (module) {\n  var entry = this;\n  var shouldRunParentSetters = false;\n\n  this.runModuleGetters(module);\n\n  Object.keys(entry.setters).forEach(function (name) {\n    var value = module.getExportByName(name);\n\n    entry.setters[name].forEach(function (setter) {\n      if (name === \"*\") {\n        Object.keys(value).forEach(function (name) {\n          if (name !== \"__esModule\" &&\n              callSetter(module, setter, name, value[name]) === true) {\n            shouldRunParentSetters = true;\n          }\n        });\n      } else if (callSetter(module, setter, name, value) === true) {\n        shouldRunParentSetters = true;\n      }\n    });\n  });\n\n  ++entry.runCount;\n\n  if (shouldRunParentSetters) {\n    entry.runParentSetters();\n  }\n};\n\nfunction callSetter(module, setter, name, value) {\n  setter.last = setter.last || Object.create(null);\n  if (! hasOwn.call(setter.last, name) ||\n      value !== setter.last[name]) {\n    return setter.call(\n      module,\n      setter.last[name] = value,\n      name\n    );\n  }\n}\n\nEp.runParentSetters = function () {\n  var parents = this.parents;\n  Object.keys(parents).forEach(function (id) {\n    runModuleSetters(parents[id]);\n  });\n};\n\nexports.Entry = Entry;\n"]}}]